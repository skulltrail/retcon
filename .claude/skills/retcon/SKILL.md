---
name: retcon
description: Organize scattered git changes into realistic, time-sequenced commits with conventional commit messages
---

# Retcon Skill

Organizes scattered working directory changes into multiple logically-grouped commits with realistic timestamps. Operates entirely through Claude conversation - no external tools required.

## Invocation

```bash
/retcon [--start "now"] [--preset irl] [--dry-run]
```

## Parameters

| Parameter   | Description                                            | Default |
| ----------- | ------------------------------------------------------ | ------- |
| `--start`   | Base timestamp for first commit                        | now     |
| `--preset`  | Timing pattern (irl, work-hours, quick-fix, deep-work) | irl     |
| `--dry-run` | Show plan without executing                            | false   |

### Start Time Formats

| Format           | Example                                  | Behavior                                       |
| ---------------- | ---------------------------------------- | ---------------------------------------------- |
| `now`            | `--start "now"`                          | Default. First commit starts from current time |
| `last commit`    | `--start "last commit"`                  | First commit is after repo's HEAD commit time  |
| Relative to last | `--start "30m after last commit"`        | Offset from last commit time                   |
| Relative to now  | `--start "2h ago"`                       | Offset backward from current time              |
| Relative forward | `--start "2h before now"`                | Same as above, clearer phrasing                |
| Absolute         | `--start "2026-01-28 14:30"`             | Specific datetime                              |
| Named            | `--start "yesterday"`, `--start "today"` | Resolves to 9am on that day                    |

## Workflow

### Phase 1: Gather Changes

1. Run `git diff HEAD` to get all uncommitted changes (staged + unstaged)
2. Run `git status` to identify new untracked files
3. Parse the diff output to identify individual hunks with file paths and line ranges

```bash
# Get all uncommitted changes
git diff HEAD

# Get list of untracked files
git status --porcelain
```

### Phase 2: Analyze and Group Hunks

Analyze each hunk's content to determine semantic grouping:

**Grouping Heuristics:**

- Function/method additions → group with related tests
- Import/require changes → group with code that uses them
- Config changes → separate commit unless tightly coupled
- Bug fixes (small targeted changes) → separate from features
- Refactoring (moves, renames) → separate from behavior changes
- Documentation changes → separate commit

**Critical Rule:** A single file may contain hunks belonging to DIFFERENT logical commits. Never assume all hunks in a file belong together.

### Phase 3: Generate Commit Messages

Use conventional commit format. **AVOID AI-sounding patterns:**

| Anti-Pattern                | Better Alternative                  |
| --------------------------- | ----------------------------------- |
| "Update X to Y"             | "refactor(x): extract helper for Y" |
| "Implement X and Y"         | Split into two commits              |
| "Various improvements"      | Be specific about what changed      |
| "Add support for X"         | "feat(module): X integration"       |
| Passive voice ("was added") | Active voice ("add")                |
| Capitalization after colon  | Lowercase after colon               |
| Period at end of subject    | No period                           |

**Good message patterns:**

- `feat(auth): oauth2 login flow`
- `fix(parser): handle empty input edge case`
- `refactor(db): connection pooling`
- `test(api): coverage for rate limiting`
- `docs(readme): setup instructions`

**CRITICAL: No AI Attribution**

- NEVER add "Co-Authored-By", "Generated by", or any AI attribution to commit messages
- Commits should appear as normal human-authored commits

### Phase 4: Calculate Timestamps

**Step 1: Resolve Start Time**

1. Get the base timestamp from `--start` (default: current time)
2. For `--start "last commit"`, use: `git log -1 --format='%aI'`
3. If repo has no commits and "last commit" is specified, fall back to current time

**Step 2: Estimate Dev Time Per Commit**

Based on the changes in each commit:

| Change Type             | Indicators                              | Dev Time |
| ----------------------- | --------------------------------------- | -------- |
| New module/file (large) | >100 lines, new file                    | 1-2h     |
| New module/file (small) | <100 lines, new file                    | 20-45m   |
| Feature addition        | New functions, exports                  | 30m-1.5h |
| Bug fix                 | Small targeted change, "fix" indicators | 10-25m   |
| Refactoring             | Renames, moves, restructuring           | 20m-1h   |
| Tests                   | Test file patterns, assertions          | 30m-1.5h |
| Config/build            | package.json, Cargo.toml, etc.          | 5-15m    |
| Documentation           | .md files, comments-only                | 10-30m   |

**Step 3: Apply Daily Accommodation Variance (High Realism)**

For `irl` preset, simulate realistic developer patterns:

**Lunch Break (12:00-13:00):**

- If a commit would land between 12:00-13:00, 50% chance to add 30-60m lunch delay
- Some commits during lunch are fine (quick fixes, grabbing laptop)

**End of Day (after 18:00):**

- 70% chance: Skip to next day 9am ± random (0-30m)
- 30% chance: Evening work session (commit through to 21:00 max)

**Night (21:00-09:00):**

- `irl` preset: Skip to 9am next day
- `deep-work` preset: Allow night commits (simulating crunch)

**Weekends:**

- `work-hours` preset: Skip to Monday 9am
- `irl` preset: 20% chance of weekend commits (passion projects, urgent fixes)
- `off-hours` preset: Weekends are prime time, commits allowed all day

**Off-Hours Preset (avoiding business hours):**

- If commit would land Mon-Fri 9am-6pm, skip to 6pm + random (0-2h)
- Favor evening sessions (6pm-11pm) and early mornings (6am-9am)
- Weekend commits spread naturally throughout the day
- Simulates side projects, personal work, open source contributions

**Micro-breaks:**

- Add 2-10m random gaps between commits (bathroom, coffee, Slack)
- Higher variance for larger commits (mental reset after big feature)

**Step 4: Add Precision-Based Randomization**

| User Input            | Precision | Randomization                    |
| --------------------- | --------- | -------------------------------- |
| `4h ago`              | hour      | ±30m within hour, random seconds |
| `4h30m ago`           | minute    | random seconds only (0-59)       |
| `2026-01-01 13:12`    | minute    | random seconds only              |
| `2026-01-01 13:12:45` | second    | no randomization                 |

**Available Presets:**

| Preset       | Gaps   | Description                                           |
| ------------ | ------ | ----------------------------------------------------- |
| `irl`        | 15m-2h | Realistic simulation (default)                        |
| `work-hours` | 30m-2h | 9am-5pm window, skip nights/weekends                  |
| `off-hours`  | 15m-2h | Avoids 9am-6pm Mon-Fri (side projects, personal work) |
| `quick-fix`  | 5-15m  | Rapid iterations                                      |
| `deep-work`  | 1-3h   | Focused sessions, allows night work                   |
| ------------ | ------ | ------------------------------                        |
| `irl`        | 15m-2h | Realistic simulation (default)                        |
| `work-hours` | 30m-2h | 9am-5pm window, skip nights/weekends                  |
| `off-hours`  | 15m-2h | Avoids 9am-6pm Mon-Fri (side projects, personal work) |
| `quick-fix`  | 5-15m  | Rapid iterations                                      |
| `deep-work`  | 1-3h   | Focused sessions, allows night work                   |

### Phase 5: Present Plan and Edit Interactively

Display the proposed commits in a clear format:

```
╔══════════════════════════════════════════════════════════════╗
║ COMMIT PLAN (3 commits, starting from last commit)           ║
╠══════════════════════════════════════════════════════════════╣

[1] feat(auth): implement JWT token validation
    Files: src/auth/jwt.rs, src/auth/mod.rs
    Hunks: 3 (145 lines added)
    Time:  Tue Jan 28 14:23:47 2026 (+32m from last commit)

[2] test(auth): add JWT validation test coverage
    Files: tests/auth_test.rs
    Hunks: 1 (67 lines added)
    Time:  Tue Jan 28 15:08:12 2026 (+44m, includes lunch break)

[3] docs(auth): add JWT setup instructions
    Files: docs/authentication.md
    Hunks: 1 (23 lines added)
    Time:  Tue Jan 28 15:31:45 2026 (+24m)

╚══════════════════════════════════════════════════════════════╝
```

**User can request changes via conversation:**

- "Change commit 1's message to: feat(auth): JWT middleware"
- "Move the config changes from commit 2 to commit 1"
- "Split commit 1 - put the mod.rs changes in a separate commit"
- "Merge commits 2 and 3"
- "Adjust commit 3's time to 4pm"
- "Add a 2 hour gap after commit 2"

After edits, Claude shows updated plan and asks for confirmation.

**Hunk View (on request):**

If user asks to see hunks for a specific file or commit:

```
═══════════════════════════════════════════════════════════════
HUNK VIEW: src/auth/jwt.rs (2 hunks)
═══════════════════════════════════════════════════════════════

[h1] Lines 45-67 → Commit 1 (feat(auth): implement JWT token validation)
     @@ -45,10 +45,23 @@ impl JwtValidator {
     + pub fn validate_token(&self, token: &str) -> Result<Claims> {
     +   let decoded = decode::<Claims>(token, &self.key, &Validation::default())?;
     ...

[h2] Lines 120-135 → Commit 1 (feat(auth): implement JWT token validation)
     @@ -120,5 +120,15 @@ impl JwtValidator {
     + fn extract_claims(&self, token: &str) -> Option<Claims> {
     ...

═══════════════════════════════════════════════════════════════
```

### Phase 6: Execute

After user confirms:

1. Create a backup tag before execution
2. For each commit in sequence:
   - Stage the specific files/hunks for that commit
   - Create the commit with backdated timestamps
3. Report success

## Execution Workflow

### Creating Backup

```bash
# Create backup tag before any changes
git tag retcon-backup-$(date +%Y%m%d-%H%M%S)
```

### Creating Commits

For each proposed commit, Claude executes:

```bash
# Stage specific files for this commit
git add "path/to/file1" "path/to/file2"

# Commit with backdated timestamp
GIT_AUTHOR_DATE='2026-01-28T14:30:45-08:00' \
GIT_COMMITTER_DATE='2026-01-28T14:30:45-08:00' \
git commit -m 'feat(scope): commit message'
```

### Partial File Staging (when hunks are split)

When different hunks from the same file go to different commits:

```bash
# Stage specific hunks interactively
git add -p "path/to/file"
# Claude will guide through hunk selection

# Or use patch mode with specific line ranges
git add --patch "path/to/file"
```

## Safety Features

- **Backup tag:** Always create `retcon-backup-{timestamp}` tag before execution
- **Protected branches:** Warn and require explicit confirmation for main/master/develop
- **Dry-run:** `--dry-run` shows plan without executing
- **Abort:** User can cancel at any point through conversation
- **Recovery:** `git reset --hard retcon-backup-{timestamp}` to undo

## Example Session

```
User: /retcon

Claude: Gathering changes...

Found 8 hunks across 4 files:
- src/auth/jwt.rs (3 hunks, +145 lines)
- src/auth/mod.rs (1 hunk, +12 lines)
- tests/auth_test.rs (2 hunks, +67 lines)
- docs/authentication.md (2 hunks, +23 lines)

Last commit: 36e6c2f at Tue Jan 28 10:15:00 2026
Using preset: irl

Analyzing semantic relationships...

╔══════════════════════════════════════════════════════════════╗
║ COMMIT PLAN (3 commits, starting from last commit)           ║
╠══════════════════════════════════════════════════════════════╣

[1] feat(auth): JWT token validation
    Files: src/auth/jwt.rs, src/auth/mod.rs
    Hunks: 4 (157 lines added)
    Time:  Tue Jan 28 11:47:23 2026 (+1h 32m from last commit)

[2] test(auth): JWT validation coverage
    Files: tests/auth_test.rs
    Hunks: 2 (67 lines added)
    Time:  Tue Jan 28 13:22:08 2026 (+1h 35m, skipped lunch)

[3] docs(auth): JWT setup instructions
    Files: docs/authentication.md
    Hunks: 2 (23 lines added)
    Time:  Tue Jan 28 13:45:51 2026 (+24m)

╚══════════════════════════════════════════════════════════════╝

Ready to execute? You can also:
- Edit messages: "Change commit 1's message to..."
- Move hunks: "Move the mod.rs changes to commit 2"
- Adjust times: "Add 30m gap after commit 1"
- View hunks: "Show me the hunks in jwt.rs"

User: Change commit 1's message to: feat(auth): JWT middleware with RS256 validation

Claude: Updated plan:

[1] feat(auth): JWT middleware with RS256 validation
    Files: src/auth/jwt.rs, src/auth/mod.rs
    Hunks: 4 (157 lines added)
    Time:  Tue Jan 28 11:47:23 2026 (+1h 32m from last commit)

[2] test(auth): JWT validation coverage
    ...

Ready to execute?

User: yes

Claude: Creating backup: retcon-backup-20260128-152347

✓ [1/3] feat(auth): JWT middleware with RS256 validation
        a3f2b1c @ Tue Jan 28 11:47:23 2026
✓ [2/3] test(auth): JWT validation coverage
        b4c3d2e @ Tue Jan 28 13:22:08 2026
✓ [3/3] docs(auth): JWT setup instructions
        c5d4e3f @ Tue Jan 28 13:45:51 2026

Done! Created 3 commits.
Backup available at: retcon-backup-20260128-152347
```
